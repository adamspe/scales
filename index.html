<!DOCTYPE html>
<style>
#container {
    margin-top: 100px;
    margin-bottom: 30px;
}
ul#triads-view {
    list-style: none;
}
.hide {
    display: none;
}
</style>
<div id="container"></div>
<div id="controls">
    <label for="roots">Root</label>
    <select id="roots"></select>
    <label for="scales">Scale</label>
    <select id="scales">
        <option></option>
    </select>
    <label for="triads">Highlight</label>
    <select id="triads"></select>
</div>
<div id="triads-view" class="hide">
    <h3>Triads</h3>
    <ul></ul>
</div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

const FLAT = (note) => `${note}\u266D`;
const SHARP = (note) => `${note}\u266F`;
const NOTES = [ 'C',SHARP('C'),'D',FLAT('E'),'E','F',SHARP('F'),'G',SHARP('G'),'A',FLAT('B'),'B'];
const CIRCULAR_NEXT = (circularArray,current) => {
    const i = circularArray.indexOf(current);
    return i < circularArray.length-1 ? circularArray[i+1] : circularArray[0];
};
const NEXT_NOTE = (note) => CIRCULAR_NEXT(NOTES,note);

class Scale {
    constructor(title,steps) {
        this.title = title;
        this.steps = steps;
        this.setRoot('C');
    }

    setRoot(root) {
        this.root = root;
        this.notes = this.steps.split('').reduce((notes,wh) => {
                let n = NEXT_NOTE(notes[notes.length-1]);
                if(wh === 'W') {
                    n = NEXT_NOTE(n);
                } else if (wh === '3') {
                    // step and one half
                    n = NEXT_NOTE(n);
                    n = NEXT_NOTE(n);
                }
                notes.push(n);
                return notes;
            },[root]);
        // steps, per my scales book, will loop back around CDEFGABC)
        if(this.notes[0] === this.notes[this.notes.length-1]) {
            this.notes.splice((this.notes.length-1),1);
        }
        this.triads = this.notes.map(one => {
            const three = CIRCULAR_NEXT(this.notes,CIRCULAR_NEXT(this.notes,one))
            const five = CIRCULAR_NEXT(this.notes,CIRCULAR_NEXT(this.notes,three))
            return [one,three,five];
        });
        this.focusedTriad = null;       
    }

    toString() {
        return `${this.root} ${this.title} \n${this.notes.join(' ')}\n${this.triads.join("\n")}`;
    }

    includes(note) {
        return this.notes.includes(note);
    }

    setFocusedTriad(triad) {
        this.focusedTriad = triad;
    }

    highlightNote(note) {
        return !!this.focusedTriad
            ? this.focusedTriad.includes(note)
            : note === this.root;
    }
}

// Declare the chart dimensions and margins.
const width = 1200;
const height = 200;
const neckPadding = 15; // distance from the edte of the neck to the E strings
const fingerRadius = neckPadding-3;
const noteYOffset = 4; // pushes the text in a finger bubble down to center it, not calculated, could be better
const fretCount = 16;
const fretWidth = 4;
const stringWidth = 2;
const nutWidth = fretWidth*2;
const topPadding = 20; // distance between highest fret and end of neck

const fretBoardLength = (width-nutWidth-topPadding);
const fretSeparation = (fretBoardLength-(fretWidth*fretCount))/fretCount;

const rootFill = '#aaa';

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

const neck = svg.append("g").attr("class","neck");
neck.append("rect")
    .attr("class","fretboard")
    .attr("width",width)
    .attr("height",height)
    .attr("fill","#fff")
    .attr("stroke","#000")
const frets = neck.append("g").attr("class","frets");
frets.append("rect")
    .attr("class","nut")
    .attr("width",nutWidth)
    .attr("height",height)
    .attr("fill","#000");

class Fret {
    constructor(index) {
        this.index = index;
        this.x = (fretBoardLength/fretCount)*(index+1);
    }

    draw() {
        frets.append("rect")
            .attr("class",`fret fret-${this.index+1}`)
            .attr("x",this.x)
            .attr("width",fretWidth)
            .attr("height",height)
            .attr("fill","#000");
        return this;
    }
}
const FRETS = [];
for(let i = 0; i < fretCount; i++) {
    FRETS.push(new Fret(i).draw());
}

// TODO dots on fretboard 3,5,7,12, etc.

const stringsG = neck.append("g")
    .attr("class","strings")
    .attr("transform",`translate(0,${neckPadding})`);
const fingers = neck.append("g")
    .attr("class","fingers")
    .attr("transform",`translate(0,${neckPadding})`);

class String {
    constructor(note,index) {
        this.note = note;
        this.index = index;
        this.y = (this.index*((height-(neckPadding*2))/5));
        this.fingerG = fingers.append("g")
            .attr("class",`fingers-${note}-${index}`)
            .attr("transform",`translate(0,${this.y})`);
    }

    draw() {
        stringsG.append("rect")
            .attr("class",`string ${this.note}`)
            .attr("width",width)
            .attr("height",stringWidth)
            .attr("y",this.y);
        return this;
    }

    notes(scale) {
        this.fingerG.selectAll('.finger').remove();
        let n = this.note;
        for(let i = 0; i < fretCount; i++) {
            n = NEXT_NOTE(n);
            if(!!scale && !scale.includes(n)) {
                continue;
            }
            const fg =  this.fingerG.append("g")
                .attr("class","finger")
            const x = FRETS[i].x-(fretSeparation/2);
            fg.append("circle")
                .attr("fill",!!scale && scale.highlightNote(n) ? rootFill : "#fff")
                .attr("stroke-width",0.5)
                .attr("stroke",'#000')
                .attr("r",fingerRadius)
                .attr("cx",x);
            fg.append("text")
                .attr("x",x)
                .attr("y",noteYOffset)
                .attr("text-anchor","middle")
                .text(n)
        }
    }
}

const strings = ['E','B','G','D','A','E'].map((node,index) => new String(node,index));
strings.forEach(s => s.draw().notes());

const SCALES = [
    new Scale("Major (Ionian)","WWHWWWH"),
    new Scale("Natural minor (Aeolian)","WHWWHWW"),
    new Scale("Dorian","WHWWWHW"),
    new Scale("Phrygian","HWWWHWW"),
    new Scale("Lydian","WWWHWWH"),
    new Scale("Mixolydian","WWHWWHW"),
    new Scale("Locrian","HWWHWWW"),
    new Scale("Harmonic minor","WHWWH3"), // has a 1.5 step = 3
    new Scale("Jazz melodic minor","WHWWWWH"),
    new Scale("Lydian flat-seven","WWWHWHW"),
    new Scale("Pentatonic (major)","WW3W3"),
    new Scale("Pentatonic (minor)","3WW3W"),
];

let currentRoot = 'C';
let currentScale = null;
let currentTriad = -1;
const triadsView = document.querySelector("#triads-view")
const triadsUl = document.querySelector("#triads-view>ul");
const triadsSelect = document.querySelector("select#triads");
function update(what) {
    if(what !== "triad") {
        while(triadsSelect.firstChild) {
            triadsSelect.removeChild(triadsSelect.lastChild);
        }
        const highLightRoot = document.createElement("option");
        highLightRoot.innerHTML = "Root note";
        triadsSelect.append(highLightRoot);
        while(triadsUl.firstChild) {
            triadsUl.removeChild(triadsUl.lastChild);
        }
        if(!!currentScale) {
            triadsView.classList.remove("hide");
            currentScale.setRoot(currentRoot);
            console.log(currentScale.toString());
            currentScale.triads.forEach((triad,index) => {
                const [one,three,five] = triad;
                const text = `[${index+1}] ${one} ${three} ${five}`;
                
                const opt = document.createElement("option");
                opt.value = index;
                opt.innerHTML = text;
                triadsSelect.append(opt);

                const li = document.createElement("li");
                li.innerHTML = text;
                triadsUl.appendChild(li);
            });
        } else {
            triadsView.classList.add("hide");
        }
    }

    strings.forEach(s => s.notes(currentScale));
}

triadsSelect.addEventListener("change",function() {
    const triadIndex = parseInt(triadsSelect.value);
    currentScale.setFocusedTriad(
        !isNaN(triadIndex)
            ? currentScale.triads[triadIndex]
            : null
    );
    update('triad');
});

const rootsSelect = document.querySelector('select#roots');
NOTES.forEach(n => {
    const opt = document.createElement("option");
    opt.value = opt.innerHTML = n;
    rootsSelect.append(opt);
});
rootsSelect.addEventListener("change",function() {
    currentRoot = rootsSelect.value;
    update("root");
});

const scalesSelect = document.querySelector('select#scales');
SCALES.forEach(scale => {
    const opt = document.createElement("option");
    opt.value = opt.innerHTML = scale.title;
    scalesSelect.append(opt);
});
scalesSelect.addEventListener("change",function() {
    currentScale = !!scalesSelect.value
        ? SCALES.find(s => s.title === scalesSelect.value)
        : null;
    update("scale");
});

// Append the SVG element.
container.append(svg.node());

</script>
